<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  />
  <title>Infinite Vertical Scroller</title>

  <style>
    /* Pull in Normalize.css for consistency */
    @import url('https://unpkg.com/normalize.css') layer(normalize);

    /* Declare layers */
    @layer normalize, base, demo;

    /* DEMO LAYER: styles for the scroller */
    @layer demo {
      .container {
        --font-level: 8;
        opacity: 0;
        height: 3lh; /* “lh” = 1× line-height */
        display: flex;
        place-items: center;
        mask: linear-gradient(
          #0000 0.25lh,
          #fff calc(50% - 0.5lh) calc(50% + 0.5lh),
          #0000 calc(100% - 0.25lh)
        );
        color: color-mix(in lch, canvasText, canvas 15%);
        text-align: center;
        position: relative;
        background: #000; /* force dark background */
      }

      ul {
        padding: 0;
        margin: 0;
        list-style-type: none;
        text-transform: uppercase;
        line-height: 1;
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold',
          sans-serif;
        height: 1lh;
        display: inline-grid;
        position: relative;
        padding-inline: 0.25em;
        align-items: center;
        align-content: center;
        justify-content: center;
        justify-items: center;
        text-align: center;
      }

      .indicator {
        --c: 0.175em;

        position: absolute;
        top: 50%;
        left: 50%;
        height: 1lh;
        translate: -50% -50%;
        border: 0.05em solid oklch(0.75 1 var(--h, 320));
        transition: width 0.25s, border-color 0.25s;
        width: calc((var(--width) * 1px) + var(--c));

        /* create little rounded-corner mask around the word */
        clip-path: polygon(
          0 0,
          var(--c) 0,
          var(--c) var(--c),
          0 var(--c),
          0 100%,
          0 calc(100% - var(--c)),
          var(--c) calc(100% - var(--c)),
          var(--c) 100%,
          0 100%,
          calc(100% - var(--c)) 100%,
          calc(100% - var(--c)) calc(100% - var(--c)),
          100% calc(100% - var(--c)),
          100% 100%,
          100% var(--c),
          calc(100% - var(--c)) var(--c),
          calc(100% - var(--c)) 0,
          100% 0,
          100% 100%,
          0 100%
        );
      }

      li {
        display: inline-block;
        width: fit-content;
        height: 1lh;
        grid-area: 1 / 1;
        line-height: 1.2;
      }
    }

    /* BASE LAYER: fluid typography + utilities */
    @layer base {
      :root {
        --font-size-min: 16;
        --font-size-max: 20;
        --font-ratio-min: 1.2;
        --font-ratio-max: 1.33;
        --font-width-min: 375;
        --font-width-max: 1500;
      }

      /* .fluid makes font “fluid” between min/max */
      :where(.fluid) {
        --fluid-min: calc(
          var(--font-size-min) *
            pow(var(--font-ratio-min), var(--font-level, 0))
        );
        --fluid-max: calc(
          var(--font-size-max) *
            pow(var(--font-ratio-max), var(--font-level, 0))
        );
        --fluid-preferred: calc(
          (var(--fluid-max) - var(--fluid-min)) /
            (var(--font-width-max) - var(--font-width-min))
        );
        --fluid-type: clamp(
          (var(--fluid-min) / 16) * 1rem,
          ((var(--fluid-min) / 16) * 1rem) -
            (((var(--fluid-preferred) * var(--font-width-min)) / 16) * 1rem) +
            (var(--fluid-preferred) * var(--variable-unit, 100vi)),
          (var(--fluid-max) / 16) * 1rem
        );
        font-size: var(--fluid-type);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        display: grid;
        place-items: center;
        min-height: 100vh;
        margin: 0;
        background: #000; /* ensure dark background */
      }
    }
  </style>
</head>

<body>
  <div class="container fluid">
    <div class="indicator"></div>
    <ul>
      <li>prototype.</li>
      <li>solve.</li>
      <li>build.</li>
      <li>develop.</li>
      <li>debug.</li>
      <li>learn.</li>
      <li>cook.</li>
      <li>ship.</li>
      <li>prompt.</li>
      <li>collaborate.</li>
      <li>create.</li>
      <li>inspire.</li>
      <li>follow.</li>
      <li>innovate.</li>
      <li>test.</li>
      <li>optimize.</li>
      <li>teach.</li>
      <li>visualize.</li>
      <li>transform.</li>
      <li>scale.</li>
      <li>do it.</li>
    </ul>
  </div>

  <script type="module">
    import gsap from 'https://cdn.skypack.dev/gsap@3.12.0';

    gsap.defaults({
      duration: 1,
    });

    // Create a paused timeline for each <li>
    const tl = gsap.timeline({ paused: true });
    const lines = gsap.utils.toArray('ul li');

    // Initially place each <li> off-screen (below) by 300% of its own height
    gsap.set('ul li', { yPercent: 300 });

    // Duplicate the array so that it can loop seamlessly
    const paddedLines = [...lines, ...lines, ...lines];

    paddedLines.forEach((line, index) => {
      // Each line has its own mini-timeline: move up by 600% (from +300% to -300%)
      const lineTl = gsap.timeline()
        .set(line, { yPercent: 300 })
        .to(
          line,
          {
            yPercent: '-=600',
            repeatRefresh: true,
            immediateRender: false,
            ease: 'none',
            duration: 6,
          },
          0
        );
      tl.add(lineTl, index);
    });

    // Create a “scrubber” timeline that drives the totalTime of tl
    const scrubber = gsap.timeline({ paused: true }).fromTo(
      tl,
      {
        totalTime: lines.length + 1,
      },
      {
        totalTime: lines.length * 2 + 1,
        ease: 'none',
        duration: lines.length,
        repeat: -1,
      }
    );

    // Seed the scrubber’s starting position so items start halfway
    gsap.set(scrubber, { totalTime: lines.length + 2 });

    // The “indicator” must wrap exactly around the currently visible word
    let index = 0;
    gsap.set('.indicator', {
      '--width': lines[index].getBoundingClientRect().width,
    });

    // On each repeat, advance “index” and update the indicator’s width & hue
    const syncIndicator = () => {
      index += 1;
      gsap.set('.indicator', {
        '--width': lines[index % lines.length].getBoundingClientRect()
          .width,
        '--h': gsap.utils.random(0, 359),
      });
    };

    gsap.to(scrubber, {
      delay: 1,
      totalTime: '+=1',
      duration: 1,
      repeat: -1,
      repeatDelay: 1,
      repeatRefresh: true,
      onStart: syncIndicator,
      onRepeat: syncIndicator,
      ease: 'elastic.out(1, 0.875)',
    });

    // Fade the container in
    gsap.set('.container', { opacity: 1 });
  </script>
</body>
</html>
