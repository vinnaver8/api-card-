<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Universe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000; /* Black background */
            overflow: hidden; /* Hide scrollbars */
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* Ensure canvas is behind everything else */
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* Hidden by default */
            font-size: 1.1rem;
            text-align: center;
            max-width: 80%; /* Limit width on smaller screens */
            word-wrap: break-word; /* Ensure long messages wrap */
        }
    </style>
</head>
<body class="bg-black text-white">
    <div id="loading-indicator" class="message-box" style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
        <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="mt-2">Loading 3D Universe...</span>
    </div>

    <div id="custom-message-box" class="message-box"></div>

    <script>
        let scene, camera, renderer, controls;
        let lines = [];
        let dots = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let currentIntersected = null; // To keep track of the currently hovered object
        let lastClickedDot = null; // To keep track of the dot that was last clicked
        let messageIsPersistent = false; // Flag to control message persistence

        // Predefined AI messages inspired by your images
        const aiMessages = [
            "DO OTHER MINDS INHABIT THE STARS?",
            "HOW DOES CONSCIOUSNESS EMERGE FROM MATTER?",
            "HOW DO BLACK HOLES RESHAPE REALITY?",
            "WHAT BINDS THE FABRIC OF SPACETIME?",
            "IS THE UNIVERSE INFINITE, OR DOES IT HAVE A BOUNDARY?",
            "ARE THERE PARALLEL UNIVERSES?",
            "WHAT IS DARK MATTER AND DARK ENERGY?",
            "HOW DID LIFE BEGIN IN THE COSMOS?"
        ];
        let messageIndex = 0; // To cycle through messages on click

        // Function to show a custom message box
        // Duration 0 means it stays until explicitly hidden (e.g., mouseleave, or new click)
        function showMessageBox(message) { // Removed duration parameter as it's now controlled by logic
            const messageBox = document.getElementById('custom-message-box');
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            clearTimeout(messageBox.hideTimeout); // Clear any existing hide timeout
        }

        // Function to hide the message box
        function hideMessageBox() {
            const messageBox = document.getElementById('custom-message-box');
            messageBox.style.display = 'none';
            clearTimeout(messageBox.hideTimeout); // Clear any existing hide timeout
        }

        function init() {
            const loadingIndicator = document.getElementById('loading-indicator');
            loadingIndicator.style.display = 'flex'; // Show loading indicator

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250; // Initial zoom out position

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for 360-degree interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.enablePan = false; // Disable panning (fixed position)
            controls.maxDistance = 500; // Limit zoom out
            controls.minDistance = 50; // Limit zoom in (prevent going through the center)

            // Generate lines and dots
            const numElements = 200;
            const lineLength = 150; // Fixed length for all lines

            for (let i = 0; i < numElements; i++) {
                // Generate a random direction vector
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize();

                // Calculate the end point based on the fixed lineLength
                const startPoint = new THREE.Vector3(0, 0, 0); // All lines originate from the center
                const endPoint = direction.clone().multiplyScalar(lineLength);

                // Line
                const points = [startPoint, endPoint];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }); // White, semi-transparent
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);

                // Dot (small cube) at the end of the line
                // Increased size for easier interaction area
                const dotGeometry = new THREE.BoxGeometry(7, 7, 7);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x93c5fd }); // Light blue
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.copy(endPoint); // Position dot explicitly at the end of the line
                dot.originalColor = dotMaterial.color.getHex(); // Store original color for hover effect
                scene.add(dot);
                dots.push(dot);
            }

            // Event Listeners for mouse interaction
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('click', onClick, false);
            // Add touch event listeners for mobile devices
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);


            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            loadingIndicator.style.display = 'none'; // Hide loading indicator
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the raycaster
            const intersects = raycaster.intersectObjects(dots);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;

                // If a new object is intersected, unhighlight the previous one (if not the last clicked)
                if (currentIntersected && currentIntersected !== intersectedObject && currentIntersected !== lastClickedDot) {
                    currentIntersected.material.color.setHex(currentIntersected.originalColor);
                }

                // Highlight the current intersected object
                if (intersectedObject.material.color.getHex() !== 0xff0000) { // Avoid re-setting if already highlighted
                    intersectedObject.material.color.setHex(0xff0000); // Highlight with red on hover
                }
                currentIntersected = intersectedObject;

                // Show message on hover, but only if no persistent message is active
                if (!messageIsPersistent || lastClickedDot !== intersectedObject) {
                    showMessageBox(aiMessages[messageIndex % aiMessages.length]);
                }

            } else {
                // If no intersection
                if (currentIntersected && currentIntersected !== lastClickedDot) {
                    currentIntersected.material.color.setHex(currentIntersected.originalColor);
                }
                currentIntersected = null;

                // Hide message only if no persistent message is active
                if (!messageIsPersistent) {
                    hideMessageBox();
                }
            }
        }

        function onClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the raycaster
            const intersects = raycaster.intersectObjects(dots);

            if (intersects.length > 0) {
                const clickedDot = intersects[0].object;

                // If a different dot is clicked, or if no dot was previously clicked
                if (lastClickedDot !== clickedDot) {
                    // Restore color of previously clicked dot if it exists and is not currently hovered
                    if (lastClickedDot && lastClickedDot !== currentIntersected) {
                        lastClickedDot.material.color.setHex(lastClickedDot.originalColor);
                    }
                    lastClickedDot = clickedDot;
                    messageIsPersistent = true; // Make message persistent

                    // Highlight the clicked dot
                    clickedDot.material.color.setHex(0xff0000);

                    // Cycle to the next message and display it persistently
                    messageIndex = (messageIndex + 1) % aiMessages.length;
                    showMessageBox(aiMessages[messageIndex]); // No duration
                } else {
                    // If the same dot is clicked again, cycle message but keep persistence
                    messageIndex = (messageIndex + 1) % aiMessages.length;
                    showMessageBox(aiMessages[messageIndex]);
                }
            } else {
                // If click happened on empty space, clear persistent message
                if (lastClickedDot) {
                    lastClickedDot.material.color.setHex(lastClickedDot.originalColor);
                }
                lastClickedDot = null;
                messageIsPersistent = false;
                hideMessageBox();
            }
        }

        // Touch event handlers for mobile
        function onTouchStart(event) {
            if (event.touches.length > 0) {
                // Prevent default touch behavior (like scrolling) for the canvas
                event.preventDefault();
                // Simulate mouse move for hover effect
                onMouseMove({
                    clientX: event.touches[0].clientX,
                    clientY: event.touches[0].clientY
                });
            }
        }

        function onTouchEnd(event) {
            // Simulate a click on touch end if an object was intersected
            // The onClick function will handle persistence and message update
            onClick({
                clientX: event.changedTouches[0].clientX,
                clientY: event.changedTouches[0].clientY
            });

            // After touch ends, if no dot was clicked, or if the message is not persistent, hide it
            if (!messageIsPersistent) {
                hideMessageBox();
            }
        }

        function onTouchMove(event) {
            if (event.touches.length > 0) {
                event.preventDefault(); // Prevent scrolling while dragging
                // Update mouse position for raycasting
                onMouseMove({
                    clientX: event.touches[0].clientX,
                    clientY: event.touches[0].clientY
                });
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Only required if controls.enableDamping or controls.autoRotate are set to true
            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
            try {
                init();
                animate();
            } catch (error) {
                console.error("Error initializing 3D scene:", error);
                showMessageBox("Failed to load 3D universe. Please try again or check console for errors.");
                document.getElementById('loading-indicator').style.display = 'none'; // Hide loading indicator on error
            }
        }
    </script>
</body>
</html>
